//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Splinter\Documents\Visual Studio 2015\Projects\RubberduckParserTest\RubberduckParserTest\VBAConditionalCompilationParser.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace Rubberduck.Parsing.Preprocessing {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class VBAConditionalCompilationParser : Parser {
	public const int
		PRINT=129, ELSEIF=56, CLOSE=31, STATIC=159, MINUS=193, OPTION_EXPLICIT=122, 
		L_SQUARE_BRACKET=204, SETATTR=155, HASHENDIF=203, DATELITERAL=211, ERROR=70, 
		NOTHING=114, EACH=54, SUB=163, FILECOPY=78, STOP=161, LPAREN=191, MID=107, 
		BEEP=20, AS=18, END_PROPERTY=61, AT=7, DATABASE=34, GOSUB=84, HASHCONST=199, 
		CHDIR=28, POW=197, DOLLAR=9, PROPERTY_LET=132, THEN=166, XOR=183, EXIT_FOR=73, 
		DEFINT=42, HASHIF=200, UNLOCK=173, CALL=26, LOCK_READ=102, SET=154, LOCK_READ_WRITE=104, 
		LSET=105, RAISEEVENT=139, SEEK=151, LONG=96, LIB=99, DIM=51, APPEND=17, 
		MKDIR=108, OPEN=119, DIV=185, PROPERTY_SET=133, PERCENT=8, SENDKEYS=153, 
		END_SELECT=62, STRING=162, HASHELSEIF=201, REM=143, TO=168, DEFDBL=40, 
		BYVAL=23, FRIEND=79, LOOP=97, DELETESETTING=50, CLASS=30, DO=52, VARIANT=175, 
		END_WITH=65, DEFBOOL=37, OPTIONAL=120, ADDRESSOF=12, CONST=33, RSET=148, 
		INTEGER=92, REMCOMMENT=213, ATTRIBUTE=15, OUTPUT=126, FOR=80, PTRSAFE=134, 
		EQ=187, BOOLEAN=22, NAME=110, END_FUNCTION=59, DEFSNG=47, DEFBYTE=38, 
		NOT=113, SAVESETTING=150, END=66, PRESERVE=128, ON_LOCAL_ERROR=118, FLOATLITERAL=209, 
		HASHELSE=202, LOAD=94, BINARY=21, RETURN=146, EXCLAMATIONPOINT=4, NEXT=111, 
		GLOBAL=83, IDENTIFIER=218, WS=217, EMPTY=57, MOD=109, WITHEVENTS=181, 
		COLON=2, DEFLNGLNG=44, STEP=160, TIME=167, OPTION_BASE=121, GT=189, PUT=136, 
		WITH=180, LOCK_WRITE=103, LINE_CONTINUATION=219, TYPEOF=171, DEFVAR=49, 
		RMDIR=147, DEFLNG=43, FALSE=77, ERRORCHAR=221, UNDERSCORE=216, INTEGERLITERAL=210, 
		END_IF=60, LOCK=95, TEXT=165, SINGLEQUOTE=215, SAVEPICTURE=149, MULT=194, 
		SEMICOLON=3, BYTE=25, HEXLITERAL=208, ELSE=55, IF=86, TYPE=170, AMPERSAND=10, 
		DEFLNGPTR=45, ENUM=67, DEFOBJ=46, IN=89, CHDRIVE=29, DOT=5, EXIT_DO=72, 
		GUIDLITERAL=220, IS=91, EQV=68, WEND=177, FUNCTION=81, HASH=6, CASE=27, 
		GEQ=188, GET=82, PUBLIC=135, ON_ERROR=117, END_ENUM=58, GOTO=85, INTDIV=186, 
		WIDTH=179, BEGIN=19, EXIT_SUB=76, ASSIGN=184, COMMENT=214, WRITE=182, 
		RANDOMIZE=138, DOUBLE=53, EXIT_PROPERTY=75, COMMA=1, RANDOM=137, PROPERTY_GET=131, 
		SELECT=152, PRIVATE=130, ERASE=69, TAB=164, BYREF=24, VERSION=176, NEQ=195, 
		END_TYPE=64, KILL=93, COLLECTION=32, NEW=112, INPUT=90, SINGLE=157, UNLOAD=172, 
		ALIAS=13, SPC=158, LT=192, RESET=144, END_SUB=63, EVENT=71, READ_WRITE=141, 
		OPTION_COMPARE=123, ME=106, NULL=115, NEWLINE=212, TRUE=169, RPAREN=198, 
		APPACTIVATE=16, IMP=87, STRINGLITERAL=206, OCTLITERAL=207, READ=140, DATE=35, 
		LIKE=100, AND=14, OPTION_PRIVATE_MODULE=124, PLUS=196, RESUME=145, SHARED=156, 
		EXIT_FUNCTION=74, ACCESS=11, LINE_INPUT=101, ON=116, OR=125, PARAMARRAY=127, 
		R_SQUARE_BRACKET=205, IMPLEMENTS=88, UNTIL=174, DEFCUR=41, DECLARE=36, 
		DEFDATE=39, REDIM=142, LEQ=190, DEFSTR=48, LET=98, WHILE=178;
	public static readonly string[] tokenNames = {
		"<INVALID>", "','", "':'", "';'", "'!'", "'.'", "'#'", "'@'", "'%'", "'$'", 
		"'&'", "ACCESS", "ADDRESSOF", "ALIAS", "AND", "ATTRIBUTE", "APPACTIVATE", 
		"APPEND", "AS", "BEGIN", "BEEP", "BINARY", "BOOLEAN", "BYVAL", "BYREF", 
		"BYTE", "CALL", "CASE", "CHDIR", "CHDRIVE", "CLASS", "CLOSE", "COLLECTION", 
		"CONST", "DATABASE", "DATE", "DECLARE", "DEFBOOL", "DEFBYTE", "DEFDATE", 
		"DEFDBL", "DEFCUR", "DEFINT", "DEFLNG", "DEFLNGLNG", "DEFLNGPTR", "DEFOBJ", 
		"DEFSNG", "DEFSTR", "DEFVAR", "DELETESETTING", "DIM", "DO", "DOUBLE", 
		"EACH", "ELSE", "ELSEIF", "EMPTY", "END_ENUM", "END_FUNCTION", "END_IF", 
		"END_PROPERTY", "END_SELECT", "END_SUB", "END_TYPE", "END_WITH", "END", 
		"ENUM", "EQV", "ERASE", "ERROR", "EVENT", "EXIT_DO", "EXIT_FOR", "EXIT_FUNCTION", 
		"EXIT_PROPERTY", "EXIT_SUB", "FALSE", "FILECOPY", "FRIEND", "FOR", "FUNCTION", 
		"GET", "GLOBAL", "GOSUB", "GOTO", "IF", "IMP", "IMPLEMENTS", "IN", "INPUT", 
		"IS", "INTEGER", "KILL", "LOAD", "LOCK", "LONG", "LOOP", "LET", "LIB", 
		"LIKE", "LINE_INPUT", "LOCK_READ", "LOCK_WRITE", "LOCK_READ_WRITE", "LSET", 
		"ME", "MID", "MKDIR", "MOD", "NAME", "NEXT", "NEW", "NOT", "NOTHING", 
		"NULL", "ON", "ON_ERROR", "ON_LOCAL_ERROR", "OPEN", "OPTIONAL", "OPTION_BASE", 
		"OPTION_EXPLICIT", "OPTION_COMPARE", "OPTION_PRIVATE_MODULE", "OR", "OUTPUT", 
		"PARAMARRAY", "PRESERVE", "PRINT", "PRIVATE", "PROPERTY_GET", "PROPERTY_LET", 
		"PROPERTY_SET", "PTRSAFE", "PUBLIC", "PUT", "RANDOM", "RANDOMIZE", "RAISEEVENT", 
		"READ", "READ_WRITE", "REDIM", "REM", "RESET", "RESUME", "RETURN", "RMDIR", 
		"RSET", "SAVEPICTURE", "SAVESETTING", "SEEK", "SELECT", "SENDKEYS", "SET", 
		"SETATTR", "SHARED", "SINGLE", "SPC", "STATIC", "STEP", "STOP", "STRING", 
		"SUB", "TAB", "TEXT", "THEN", "TIME", "TO", "TRUE", "TYPE", "TYPEOF", 
		"UNLOAD", "UNLOCK", "UNTIL", "VARIANT", "VERSION", "WEND", "WHILE", "WIDTH", 
		"WITH", "WITHEVENTS", "WRITE", "XOR", "':='", "'/'", "'\\'", "'='", "GEQ", 
		"'>'", "LEQ", "'('", "'<'", "'-'", "'*'", "NEQ", "'+'", "'^'", "')'", 
		"HASHCONST", "HASHIF", "HASHELSEIF", "HASHELSE", "HASHENDIF", "'['", "']'", 
		"STRINGLITERAL", "OCTLITERAL", "HEXLITERAL", "FLOATLITERAL", "INTEGERLITERAL", 
		"DATELITERAL", "NEWLINE", "REMCOMMENT", "COMMENT", "'''", "'_'", "WS", 
		"IDENTIFIER", "LINE_CONTINUATION", "GUIDLITERAL", "ERRORCHAR"
	};
	public const int
		RULE_compilationUnit = 0, RULE_ccBlock = 1, RULE_ccConst = 2, RULE_logicalLine = 3, 
		RULE_extendedLine = 4, RULE_ccVarLhs = 5, RULE_ccExpression = 6, RULE_ccIfBlock = 7, 
		RULE_ccIf = 8, RULE_ccElseIfBlock = 9, RULE_ccElseIf = 10, RULE_ccElseBlock = 11, 
		RULE_ccElse = 12, RULE_ccEndIf = 13, RULE_ccEol = 14, RULE_intrinsicFunction = 15, 
		RULE_intrinsicFunctionName = 16, RULE_name = 17, RULE_typeHint = 18, RULE_literal = 19;
	public static readonly string[] ruleNames = {
		"compilationUnit", "ccBlock", "ccConst", "logicalLine", "extendedLine", 
		"ccVarLhs", "ccExpression", "ccIfBlock", "ccIf", "ccElseIfBlock", "ccElseIf", 
		"ccElseBlock", "ccElse", "ccEndIf", "ccEol", "intrinsicFunction", "intrinsicFunctionName", 
		"name", "typeHint", "literal"
	};

	public override string GrammarFileName { get { return "VBAConditionalCompilationParser.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public VBAConditionalCompilationParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class CompilationUnitContext : ParserRuleContext {
		public CcBlockContext ccBlock() {
			return GetRuleContext<CcBlockContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(VBAConditionalCompilationParser.Eof, 0); }
		public CompilationUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compilationUnit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCompilationUnit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCompilationUnit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompilationUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompilationUnitContext compilationUnit() {
		CompilationUnitContext _localctx = new CompilationUnitContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_compilationUnit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 40; ccBlock();
			State = 41; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcBlockContext : ParserRuleContext {
		public CcIfBlockContext ccIfBlock(int i) {
			return GetRuleContext<CcIfBlockContext>(i);
		}
		public IReadOnlyList<LogicalLineContext> logicalLine() {
			return GetRuleContexts<LogicalLineContext>();
		}
		public IReadOnlyList<CcIfBlockContext> ccIfBlock() {
			return GetRuleContexts<CcIfBlockContext>();
		}
		public LogicalLineContext logicalLine(int i) {
			return GetRuleContext<LogicalLineContext>(i);
		}
		public IReadOnlyList<CcConstContext> ccConst() {
			return GetRuleContexts<CcConstContext>();
		}
		public CcConstContext ccConst(int i) {
			return GetRuleContext<CcConstContext>(i);
		}
		public CcBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcBlockContext ccBlock() {
		CcBlockContext _localctx = new CcBlockContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_ccBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 48;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << COMMA) | (1L << COLON) | (1L << SEMICOLON) | (1L << EXCLAMATIONPOINT) | (1L << DOT) | (1L << HASH) | (1L << AT) | (1L << PERCENT) | (1L << DOLLAR) | (1L << AMPERSAND) | (1L << ACCESS) | (1L << ADDRESSOF) | (1L << ALIAS) | (1L << AND) | (1L << ATTRIBUTE) | (1L << APPACTIVATE) | (1L << APPEND) | (1L << AS) | (1L << BEGIN) | (1L << BEEP) | (1L << BINARY) | (1L << BOOLEAN) | (1L << BYVAL) | (1L << BYREF) | (1L << BYTE) | (1L << CALL) | (1L << CASE) | (1L << CHDIR) | (1L << CHDRIVE) | (1L << CLASS) | (1L << CLOSE) | (1L << COLLECTION) | (1L << CONST) | (1L << DATABASE) | (1L << DATE) | (1L << DECLARE) | (1L << DEFBOOL) | (1L << DEFBYTE) | (1L << DEFDATE) | (1L << DEFDBL) | (1L << DEFCUR) | (1L << DEFINT) | (1L << DEFLNG) | (1L << DEFLNGLNG) | (1L << DEFLNGPTR) | (1L << DEFOBJ) | (1L << DEFSNG) | (1L << DEFSTR) | (1L << DEFVAR) | (1L << DELETESETTING) | (1L << DIM) | (1L << DO) | (1L << DOUBLE) | (1L << EACH) | (1L << ELSE) | (1L << ELSEIF) | (1L << EMPTY) | (1L << END_ENUM) | (1L << END_FUNCTION) | (1L << END_IF) | (1L << END_PROPERTY) | (1L << END_SELECT) | (1L << END_SUB))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (END_TYPE - 64)) | (1L << (END_WITH - 64)) | (1L << (END - 64)) | (1L << (ENUM - 64)) | (1L << (EQV - 64)) | (1L << (ERASE - 64)) | (1L << (ERROR - 64)) | (1L << (EVENT - 64)) | (1L << (EXIT_DO - 64)) | (1L << (EXIT_FOR - 64)) | (1L << (EXIT_FUNCTION - 64)) | (1L << (EXIT_PROPERTY - 64)) | (1L << (EXIT_SUB - 64)) | (1L << (FALSE - 64)) | (1L << (FILECOPY - 64)) | (1L << (FRIEND - 64)) | (1L << (FOR - 64)) | (1L << (FUNCTION - 64)) | (1L << (GET - 64)) | (1L << (GLOBAL - 64)) | (1L << (GOSUB - 64)) | (1L << (GOTO - 64)) | (1L << (IF - 64)) | (1L << (IMP - 64)) | (1L << (IMPLEMENTS - 64)) | (1L << (IN - 64)) | (1L << (INPUT - 64)) | (1L << (IS - 64)) | (1L << (INTEGER - 64)) | (1L << (KILL - 64)) | (1L << (LOAD - 64)) | (1L << (LOCK - 64)) | (1L << (LONG - 64)) | (1L << (LOOP - 64)) | (1L << (LET - 64)) | (1L << (LIB - 64)) | (1L << (LIKE - 64)) | (1L << (LINE_INPUT - 64)) | (1L << (LOCK_READ - 64)) | (1L << (LOCK_WRITE - 64)) | (1L << (LOCK_READ_WRITE - 64)) | (1L << (LSET - 64)) | (1L << (ME - 64)) | (1L << (MID - 64)) | (1L << (MKDIR - 64)) | (1L << (MOD - 64)) | (1L << (NAME - 64)) | (1L << (NEXT - 64)) | (1L << (NEW - 64)) | (1L << (NOT - 64)) | (1L << (NOTHING - 64)) | (1L << (NULL - 64)) | (1L << (ON - 64)) | (1L << (ON_ERROR - 64)) | (1L << (ON_LOCAL_ERROR - 64)) | (1L << (OPEN - 64)) | (1L << (OPTIONAL - 64)) | (1L << (OPTION_BASE - 64)) | (1L << (OPTION_EXPLICIT - 64)) | (1L << (OPTION_COMPARE - 64)) | (1L << (OPTION_PRIVATE_MODULE - 64)) | (1L << (OR - 64)) | (1L << (OUTPUT - 64)) | (1L << (PARAMARRAY - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (PRESERVE - 128)) | (1L << (PRINT - 128)) | (1L << (PRIVATE - 128)) | (1L << (PROPERTY_GET - 128)) | (1L << (PROPERTY_LET - 128)) | (1L << (PROPERTY_SET - 128)) | (1L << (PTRSAFE - 128)) | (1L << (PUBLIC - 128)) | (1L << (PUT - 128)) | (1L << (RANDOM - 128)) | (1L << (RANDOMIZE - 128)) | (1L << (RAISEEVENT - 128)) | (1L << (READ - 128)) | (1L << (READ_WRITE - 128)) | (1L << (REDIM - 128)) | (1L << (REM - 128)) | (1L << (RESET - 128)) | (1L << (RESUME - 128)) | (1L << (RETURN - 128)) | (1L << (RMDIR - 128)) | (1L << (RSET - 128)) | (1L << (SAVEPICTURE - 128)) | (1L << (SAVESETTING - 128)) | (1L << (SEEK - 128)) | (1L << (SELECT - 128)) | (1L << (SENDKEYS - 128)) | (1L << (SET - 128)) | (1L << (SETATTR - 128)) | (1L << (SHARED - 128)) | (1L << (SINGLE - 128)) | (1L << (SPC - 128)) | (1L << (STATIC - 128)) | (1L << (STEP - 128)) | (1L << (STOP - 128)) | (1L << (STRING - 128)) | (1L << (SUB - 128)) | (1L << (TAB - 128)) | (1L << (TEXT - 128)) | (1L << (THEN - 128)) | (1L << (TIME - 128)) | (1L << (TO - 128)) | (1L << (TRUE - 128)) | (1L << (TYPE - 128)) | (1L << (TYPEOF - 128)) | (1L << (UNLOAD - 128)) | (1L << (UNLOCK - 128)) | (1L << (UNTIL - 128)) | (1L << (VARIANT - 128)) | (1L << (VERSION - 128)) | (1L << (WEND - 128)) | (1L << (WHILE - 128)) | (1L << (WIDTH - 128)) | (1L << (WITH - 128)) | (1L << (WITHEVENTS - 128)) | (1L << (WRITE - 128)) | (1L << (XOR - 128)) | (1L << (ASSIGN - 128)) | (1L << (DIV - 128)) | (1L << (INTDIV - 128)) | (1L << (EQ - 128)) | (1L << (GEQ - 128)) | (1L << (GT - 128)) | (1L << (LEQ - 128)) | (1L << (LPAREN - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (LT - 192)) | (1L << (MINUS - 192)) | (1L << (MULT - 192)) | (1L << (NEQ - 192)) | (1L << (PLUS - 192)) | (1L << (POW - 192)) | (1L << (RPAREN - 192)) | (1L << (HASHCONST - 192)) | (1L << (HASHIF - 192)) | (1L << (L_SQUARE_BRACKET - 192)) | (1L << (R_SQUARE_BRACKET - 192)) | (1L << (STRINGLITERAL - 192)) | (1L << (OCTLITERAL - 192)) | (1L << (HEXLITERAL - 192)) | (1L << (FLOATLITERAL - 192)) | (1L << (INTEGERLITERAL - 192)) | (1L << (DATELITERAL - 192)) | (1L << (NEWLINE - 192)) | (1L << (REMCOMMENT - 192)) | (1L << (COMMENT - 192)) | (1L << (SINGLEQUOTE - 192)) | (1L << (UNDERSCORE - 192)) | (1L << (WS - 192)) | (1L << (IDENTIFIER - 192)) | (1L << (LINE_CONTINUATION - 192)) | (1L << (GUIDLITERAL - 192)) | (1L << (ERRORCHAR - 192)))) != 0)) {
				{
				State = 46;
				switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
				case 1:
					{
					State = 43; ccConst();
					}
					break;

				case 2:
					{
					State = 44; ccIfBlock();
					}
					break;

				case 3:
					{
					State = 45; logicalLine();
					}
					break;
				}
				}
				State = 50;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcConstContext : ParserRuleContext {
		public CcVarLhsContext ccVarLhs() {
			return GetRuleContext<CcVarLhsContext>(0);
		}
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode EQ() { return GetToken(VBAConditionalCompilationParser.EQ, 0); }
		public ITerminalNode HASHCONST() { return GetToken(VBAConditionalCompilationParser.HASHCONST, 0); }
		public CcEolContext ccEol() {
			return GetRuleContext<CcEolContext>(0);
		}
		public CcExpressionContext ccExpression() {
			return GetRuleContext<CcExpressionContext>(0);
		}
		public CcConstContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccConst; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcConst(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcConst(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcConst(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcConstContext ccConst() {
		CcConstContext _localctx = new CcConstContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_ccConst);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 54;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 51; Match(WS);
				}
				}
				State = 56;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 57; Match(HASHCONST);
			State = 59;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 58; Match(WS);
				}
				}
				State = 61;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 63; ccVarLhs();
			State = 65;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 64; Match(WS);
				}
				}
				State = 67;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 69; Match(EQ);
			State = 71;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 70; Match(WS);
				}
				}
				State = 73;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 75; ccExpression(0);
			State = 76; ccEol();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LogicalLineContext : ParserRuleContext {
		public IReadOnlyList<ExtendedLineContext> extendedLine() {
			return GetRuleContexts<ExtendedLineContext>();
		}
		public ExtendedLineContext extendedLine(int i) {
			return GetRuleContext<ExtendedLineContext>(i);
		}
		public LogicalLineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logicalLine; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterLogicalLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitLogicalLine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LogicalLineContext logicalLine() {
		LogicalLineContext _localctx = new LogicalLineContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_logicalLine);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 79;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 78; extendedLine();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 81;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,6,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtendedLineContext : ParserRuleContext {
		public IReadOnlyList<ITerminalNode> HASHIF() { return GetTokens(VBAConditionalCompilationParser.HASHIF); }
		public IReadOnlyList<ITerminalNode> HASHENDIF() { return GetTokens(VBAConditionalCompilationParser.HASHENDIF); }
		public ITerminalNode HASHENDIF(int i) {
			return GetToken(VBAConditionalCompilationParser.HASHENDIF, i);
		}
		public ITerminalNode NEWLINE() { return GetToken(VBAConditionalCompilationParser.NEWLINE, 0); }
		public IReadOnlyList<ITerminalNode> HASHELSE() { return GetTokens(VBAConditionalCompilationParser.HASHELSE); }
		public IReadOnlyList<ITerminalNode> HASHELSEIF() { return GetTokens(VBAConditionalCompilationParser.HASHELSEIF); }
		public ITerminalNode HASHCONST(int i) {
			return GetToken(VBAConditionalCompilationParser.HASHCONST, i);
		}
		public ITerminalNode HASHIF(int i) {
			return GetToken(VBAConditionalCompilationParser.HASHIF, i);
		}
		public IReadOnlyList<ITerminalNode> LINE_CONTINUATION() { return GetTokens(VBAConditionalCompilationParser.LINE_CONTINUATION); }
		public ITerminalNode LINE_CONTINUATION(int i) {
			return GetToken(VBAConditionalCompilationParser.LINE_CONTINUATION, i);
		}
		public IReadOnlyList<ITerminalNode> HASHCONST() { return GetTokens(VBAConditionalCompilationParser.HASHCONST); }
		public ITerminalNode HASHELSEIF(int i) {
			return GetToken(VBAConditionalCompilationParser.HASHELSEIF, i);
		}
		public ITerminalNode HASHELSE(int i) {
			return GetToken(VBAConditionalCompilationParser.HASHELSE, i);
		}
		public ExtendedLineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extendedLine; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterExtendedLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitExtendedLine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExtendedLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExtendedLineContext extendedLine() {
		ExtendedLineContext _localctx = new ExtendedLineContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_extendedLine);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 85;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					State = 85;
					switch ( Interpreter.AdaptivePredict(_input,7,_ctx) ) {
					case 1:
						{
						State = 83; Match(LINE_CONTINUATION);
						}
						break;

					case 2:
						{
						State = 84;
						_la = _input.La(1);
						if ( _la <= 0 || (((((_la - 199)) & ~0x3f) == 0 && ((1L << (_la - 199)) & ((1L << (HASHCONST - 199)) | (1L << (HASHIF - 199)) | (1L << (HASHELSEIF - 199)) | (1L << (HASHELSE - 199)) | (1L << (HASHENDIF - 199)))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						}
						break;
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 87;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,8,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			State = 90;
			switch ( Interpreter.AdaptivePredict(_input,9,_ctx) ) {
			case 1:
				{
				State = 89; Match(NEWLINE);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcVarLhsContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public CcVarLhsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccVarLhs; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcVarLhs(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcVarLhs(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcVarLhs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcVarLhsContext ccVarLhs() {
		CcVarLhsContext _localctx = new CcVarLhsContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_ccVarLhs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 92; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcExpressionContext : ParserRuleContext {
		public ITerminalNode XOR() { return GetToken(VBAConditionalCompilationParser.XOR, 0); }
		public ITerminalNode EQV() { return GetToken(VBAConditionalCompilationParser.EQV, 0); }
		public ITerminalNode AMPERSAND() { return GetToken(VBAConditionalCompilationParser.AMPERSAND, 0); }
		public IReadOnlyList<CcExpressionContext> ccExpression() {
			return GetRuleContexts<CcExpressionContext>();
		}
		public ITerminalNode INTDIV() { return GetToken(VBAConditionalCompilationParser.INTDIV, 0); }
		public ITerminalNode NOT() { return GetToken(VBAConditionalCompilationParser.NOT, 0); }
		public ITerminalNode GEQ() { return GetToken(VBAConditionalCompilationParser.GEQ, 0); }
		public ITerminalNode LPAREN() { return GetToken(VBAConditionalCompilationParser.LPAREN, 0); }
		public ITerminalNode LEQ() { return GetToken(VBAConditionalCompilationParser.LEQ, 0); }
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public ITerminalNode AND() { return GetToken(VBAConditionalCompilationParser.AND, 0); }
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode IMP() { return GetToken(VBAConditionalCompilationParser.IMP, 0); }
		public CcExpressionContext ccExpression(int i) {
			return GetRuleContext<CcExpressionContext>(i);
		}
		public ITerminalNode POW() { return GetToken(VBAConditionalCompilationParser.POW, 0); }
		public ITerminalNode DIV() { return GetToken(VBAConditionalCompilationParser.DIV, 0); }
		public ITerminalNode NEQ() { return GetToken(VBAConditionalCompilationParser.NEQ, 0); }
		public IntrinsicFunctionContext intrinsicFunction() {
			return GetRuleContext<IntrinsicFunctionContext>(0);
		}
		public ITerminalNode MULT() { return GetToken(VBAConditionalCompilationParser.MULT, 0); }
		public ITerminalNode LT() { return GetToken(VBAConditionalCompilationParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(VBAConditionalCompilationParser.GT, 0); }
		public ITerminalNode RPAREN() { return GetToken(VBAConditionalCompilationParser.RPAREN, 0); }
		public ITerminalNode MOD() { return GetToken(VBAConditionalCompilationParser.MOD, 0); }
		public ITerminalNode OR() { return GetToken(VBAConditionalCompilationParser.OR, 0); }
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public ITerminalNode IS() { return GetToken(VBAConditionalCompilationParser.IS, 0); }
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode MINUS() { return GetToken(VBAConditionalCompilationParser.MINUS, 0); }
		public ITerminalNode PLUS() { return GetToken(VBAConditionalCompilationParser.PLUS, 0); }
		public ITerminalNode EQ() { return GetToken(VBAConditionalCompilationParser.EQ, 0); }
		public ITerminalNode LIKE() { return GetToken(VBAConditionalCompilationParser.LIKE, 0); }
		public CcExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcExpressionContext ccExpression() {
		return ccExpression(0);
	}

	private CcExpressionContext ccExpression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		CcExpressionContext _localctx = new CcExpressionContext(_ctx, _parentState);
		CcExpressionContext _prevctx = _localctx;
		int _startState = 12;
		EnterRecursionRule(_localctx, 12, RULE_ccExpression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 130;
			switch ( Interpreter.AdaptivePredict(_input,14,_ctx) ) {
			case 1:
				{
				State = 95; Match(MINUS);
				State = 99;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==WS) {
					{
					{
					State = 96; Match(WS);
					}
					}
					State = 101;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 102; ccExpression(16);
				}
				break;

			case 2:
				{
				State = 103; Match(NOT);
				State = 107;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==WS) {
					{
					{
					State = 104; Match(WS);
					}
					}
					State = 109;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 110; ccExpression(9);
				}
				break;

			case 3:
				{
				State = 111; Match(LPAREN);
				State = 115;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==WS) {
					{
					{
					State = 112; Match(WS);
					}
					}
					State = 117;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 118; ccExpression(0);
				State = 122;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==WS) {
					{
					{
					State = 119; Match(WS);
					}
					}
					State = 124;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 125; Match(RPAREN);
				}
				break;

			case 4:
				{
				State = 127; intrinsicFunction();
				}
				break;

			case 5:
				{
				State = 128; literal();
				}
				break;

			case 6:
				{
				State = 129; name();
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 314;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,40,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 312;
					switch ( Interpreter.AdaptivePredict(_input,39,_ctx) ) {
					case 1:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 132;
						if (!(Precpred(_ctx, 17))) throw new FailedPredicateException(this, "Precpred(_ctx, 17)");
						State = 136;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 133; Match(WS);
							}
							}
							State = 138;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 139; Match(POW);
						State = 143;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 140; Match(WS);
							}
							}
							State = 145;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 146; ccExpression(18);
						}
						break;

					case 2:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 147;
						if (!(Precpred(_ctx, 15))) throw new FailedPredicateException(this, "Precpred(_ctx, 15)");
						State = 151;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 148; Match(WS);
							}
							}
							State = 153;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 154;
						_la = _input.La(1);
						if ( !(_la==DIV || _la==MULT) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 158;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 155; Match(WS);
							}
							}
							State = 160;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 161; ccExpression(16);
						}
						break;

					case 3:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 162;
						if (!(Precpred(_ctx, 14))) throw new FailedPredicateException(this, "Precpred(_ctx, 14)");
						State = 166;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 163; Match(WS);
							}
							}
							State = 168;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 169; Match(INTDIV);
						State = 173;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 170; Match(WS);
							}
							}
							State = 175;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 176; ccExpression(15);
						}
						break;

					case 4:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 177;
						if (!(Precpred(_ctx, 13))) throw new FailedPredicateException(this, "Precpred(_ctx, 13)");
						State = 181;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 178; Match(WS);
							}
							}
							State = 183;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 184; Match(MOD);
						State = 188;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 185; Match(WS);
							}
							}
							State = 190;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 191; ccExpression(14);
						}
						break;

					case 5:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 192;
						if (!(Precpred(_ctx, 12))) throw new FailedPredicateException(this, "Precpred(_ctx, 12)");
						State = 196;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 193; Match(WS);
							}
							}
							State = 198;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 199;
						_la = _input.La(1);
						if ( !(_la==MINUS || _la==PLUS) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 203;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 200; Match(WS);
							}
							}
							State = 205;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 206; ccExpression(13);
						}
						break;

					case 6:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 207;
						if (!(Precpred(_ctx, 11))) throw new FailedPredicateException(this, "Precpred(_ctx, 11)");
						State = 211;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 208; Match(WS);
							}
							}
							State = 213;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 214; Match(AMPERSAND);
						State = 218;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 215; Match(WS);
							}
							}
							State = 220;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 221; ccExpression(12);
						}
						break;

					case 7:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 222;
						if (!(Precpred(_ctx, 10))) throw new FailedPredicateException(this, "Precpred(_ctx, 10)");
						State = 226;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 223; Match(WS);
							}
							}
							State = 228;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 229;
						_la = _input.La(1);
						if ( !(_la==IS || _la==LIKE || ((((_la - 187)) & ~0x3f) == 0 && ((1L << (_la - 187)) & ((1L << (EQ - 187)) | (1L << (GEQ - 187)) | (1L << (GT - 187)) | (1L << (LEQ - 187)) | (1L << (LT - 187)) | (1L << (NEQ - 187)))) != 0)) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						State = 233;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 230; Match(WS);
							}
							}
							State = 235;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 236; ccExpression(11);
						}
						break;

					case 8:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 237;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 241;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 238; Match(WS);
							}
							}
							State = 243;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 244; Match(AND);
						State = 248;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 245; Match(WS);
							}
							}
							State = 250;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 251; ccExpression(9);
						}
						break;

					case 9:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 252;
						if (!(Precpred(_ctx, 7))) throw new FailedPredicateException(this, "Precpred(_ctx, 7)");
						State = 256;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 253; Match(WS);
							}
							}
							State = 258;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 259; Match(OR);
						State = 263;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 260; Match(WS);
							}
							}
							State = 265;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 266; ccExpression(8);
						}
						break;

					case 10:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 267;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 271;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 268; Match(WS);
							}
							}
							State = 273;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 274; Match(XOR);
						State = 278;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 275; Match(WS);
							}
							}
							State = 280;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 281; ccExpression(7);
						}
						break;

					case 11:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 282;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 286;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 283; Match(WS);
							}
							}
							State = 288;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 289; Match(EQV);
						State = 293;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 290; Match(WS);
							}
							}
							State = 295;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 296; ccExpression(6);
						}
						break;

					case 12:
						{
						_localctx = new CcExpressionContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_ccExpression);
						State = 297;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 301;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 298; Match(WS);
							}
							}
							State = 303;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 304; Match(IMP);
						State = 308;
						_errHandler.Sync(this);
						_la = _input.La(1);
						while (_la==WS) {
							{
							{
							State = 305; Match(WS);
							}
							}
							State = 310;
							_errHandler.Sync(this);
							_la = _input.La(1);
						}
						State = 311; ccExpression(5);
						}
						break;
					}
					} 
				}
				State = 316;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,40,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class CcIfBlockContext : ParserRuleContext {
		public CcIfContext ccIf() {
			return GetRuleContext<CcIfContext>(0);
		}
		public CcBlockContext ccBlock() {
			return GetRuleContext<CcBlockContext>(0);
		}
		public CcElseIfBlockContext ccElseIfBlock(int i) {
			return GetRuleContext<CcElseIfBlockContext>(i);
		}
		public CcEndIfContext ccEndIf() {
			return GetRuleContext<CcEndIfContext>(0);
		}
		public CcElseBlockContext ccElseBlock() {
			return GetRuleContext<CcElseBlockContext>(0);
		}
		public IReadOnlyList<CcElseIfBlockContext> ccElseIfBlock() {
			return GetRuleContexts<CcElseIfBlockContext>();
		}
		public CcIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccIfBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcIfBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcIfBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcIfBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcIfBlockContext ccIfBlock() {
		CcIfBlockContext _localctx = new CcIfBlockContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_ccIfBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 317; ccIf();
			State = 318; ccBlock();
			State = 322;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==HASHELSEIF) {
				{
				{
				State = 319; ccElseIfBlock();
				}
				}
				State = 324;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 326;
			_la = _input.La(1);
			if (_la==HASHELSE) {
				{
				State = 325; ccElseBlock();
				}
			}

			State = 328; ccEndIf();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcIfContext : ParserRuleContext {
		public ITerminalNode HASHIF() { return GetToken(VBAConditionalCompilationParser.HASHIF, 0); }
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode THEN() { return GetToken(VBAConditionalCompilationParser.THEN, 0); }
		public CcEolContext ccEol() {
			return GetRuleContext<CcEolContext>(0);
		}
		public CcExpressionContext ccExpression() {
			return GetRuleContext<CcExpressionContext>(0);
		}
		public CcIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccIf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcIf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcIf(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcIf(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcIfContext ccIf() {
		CcIfContext _localctx = new CcIfContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_ccIf);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 330; Match(HASHIF);
			State = 332;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 331; Match(WS);
				}
				}
				State = 334;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 336; ccExpression(0);
			State = 338;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 337; Match(WS);
				}
				}
				State = 340;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 342; Match(THEN);
			State = 343; ccEol();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcElseIfBlockContext : ParserRuleContext {
		public CcBlockContext ccBlock() {
			return GetRuleContext<CcBlockContext>(0);
		}
		public CcElseIfContext ccElseIf() {
			return GetRuleContext<CcElseIfContext>(0);
		}
		public CcElseIfBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccElseIfBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcElseIfBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcElseIfBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcElseIfBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcElseIfBlockContext ccElseIfBlock() {
		CcElseIfBlockContext _localctx = new CcElseIfBlockContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_ccElseIfBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 345; ccElseIf();
			State = 346; ccBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcElseIfContext : ParserRuleContext {
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode THEN() { return GetToken(VBAConditionalCompilationParser.THEN, 0); }
		public CcEolContext ccEol() {
			return GetRuleContext<CcEolContext>(0);
		}
		public ITerminalNode HASHELSEIF() { return GetToken(VBAConditionalCompilationParser.HASHELSEIF, 0); }
		public CcExpressionContext ccExpression() {
			return GetRuleContext<CcExpressionContext>(0);
		}
		public CcElseIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccElseIf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcElseIf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcElseIf(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcElseIf(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcElseIfContext ccElseIf() {
		CcElseIfContext _localctx = new CcElseIfContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_ccElseIf);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 348; Match(HASHELSEIF);
			State = 350;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 349; Match(WS);
				}
				}
				State = 352;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 354; ccExpression(0);
			State = 356;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 355; Match(WS);
				}
				}
				State = 358;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WS );
			State = 360; Match(THEN);
			State = 361; ccEol();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcElseBlockContext : ParserRuleContext {
		public CcBlockContext ccBlock() {
			return GetRuleContext<CcBlockContext>(0);
		}
		public CcElseContext ccElse() {
			return GetRuleContext<CcElseContext>(0);
		}
		public CcElseBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccElseBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcElseBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcElseBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcElseBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcElseBlockContext ccElseBlock() {
		CcElseBlockContext _localctx = new CcElseBlockContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_ccElseBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 363; ccElse();
			State = 364; ccBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcElseContext : ParserRuleContext {
		public ITerminalNode HASHELSE() { return GetToken(VBAConditionalCompilationParser.HASHELSE, 0); }
		public CcEolContext ccEol() {
			return GetRuleContext<CcEolContext>(0);
		}
		public CcElseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccElse; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcElse(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcElse(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcElse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcElseContext ccElse() {
		CcElseContext _localctx = new CcElseContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_ccElse);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 366; Match(HASHELSE);
			State = 367; ccEol();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcEndIfContext : ParserRuleContext {
		public ITerminalNode HASHENDIF() { return GetToken(VBAConditionalCompilationParser.HASHENDIF, 0); }
		public CcEolContext ccEol() {
			return GetRuleContext<CcEolContext>(0);
		}
		public CcEndIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccEndIf; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcEndIf(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcEndIf(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcEndIf(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcEndIfContext ccEndIf() {
		CcEndIfContext _localctx = new CcEndIfContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_ccEndIf);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 369; Match(HASHENDIF);
			State = 370; ccEol();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CcEolContext : ParserRuleContext {
		public ITerminalNode SINGLEQUOTE() { return GetToken(VBAConditionalCompilationParser.SINGLEQUOTE, 0); }
		public IReadOnlyList<ITerminalNode> NEWLINE() { return GetTokens(VBAConditionalCompilationParser.NEWLINE); }
		public ITerminalNode NEWLINE(int i) {
			return GetToken(VBAConditionalCompilationParser.NEWLINE, i);
		}
		public CcEolContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ccEol; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterCcEol(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitCcEol(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCcEol(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CcEolContext ccEol() {
		CcEolContext _localctx = new CcEolContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_ccEol);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 379;
			switch ( Interpreter.AdaptivePredict(_input,48,_ctx) ) {
			case 1:
				{
				State = 372; Match(SINGLEQUOTE);
				State = 376;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,47,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 373;
						_la = _input.La(1);
						if ( _la <= 0 || (_la==NEWLINE) ) {
						_errHandler.RecoverInline(this);
						}
						Consume();
						}
						} 
					}
					State = 378;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,47,_ctx);
				}
				}
				break;
			}
			State = 382;
			switch ( Interpreter.AdaptivePredict(_input,49,_ctx) ) {
			case 1:
				{
				State = 381; Match(NEWLINE);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntrinsicFunctionContext : ParserRuleContext {
		public IntrinsicFunctionNameContext intrinsicFunctionName() {
			return GetRuleContext<IntrinsicFunctionNameContext>(0);
		}
		public ITerminalNode WS(int i) {
			return GetToken(VBAConditionalCompilationParser.WS, i);
		}
		public ITerminalNode LPAREN() { return GetToken(VBAConditionalCompilationParser.LPAREN, 0); }
		public IReadOnlyList<ITerminalNode> WS() { return GetTokens(VBAConditionalCompilationParser.WS); }
		public ITerminalNode RPAREN() { return GetToken(VBAConditionalCompilationParser.RPAREN, 0); }
		public CcExpressionContext ccExpression() {
			return GetRuleContext<CcExpressionContext>(0);
		}
		public IntrinsicFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intrinsicFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterIntrinsicFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitIntrinsicFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntrinsicFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntrinsicFunctionContext intrinsicFunction() {
		IntrinsicFunctionContext _localctx = new IntrinsicFunctionContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_intrinsicFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 384; intrinsicFunctionName();
			State = 385; Match(LPAREN);
			State = 389;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 386; Match(WS);
				}
				}
				State = 391;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 392; ccExpression(0);
			State = 396;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==WS) {
				{
				{
				State = 393; Match(WS);
				}
				}
				State = 398;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 399; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntrinsicFunctionNameContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(VBAConditionalCompilationParser.IDENTIFIER, 0); }
		public IntrinsicFunctionNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intrinsicFunctionName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterIntrinsicFunctionName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitIntrinsicFunctionName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntrinsicFunctionName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntrinsicFunctionNameContext intrinsicFunctionName() {
		IntrinsicFunctionNameContext _localctx = new IntrinsicFunctionNameContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_intrinsicFunctionName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 401; Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public TypeHintContext typeHint() {
			return GetRuleContext<TypeHintContext>(0);
		}
		public ITerminalNode IDENTIFIER() { return GetToken(VBAConditionalCompilationParser.IDENTIFIER, 0); }
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 403; Match(IDENTIFIER);
			State = 405;
			switch ( Interpreter.AdaptivePredict(_input,52,_ctx) ) {
			case 1:
				{
				State = 404; typeHint();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeHintContext : ParserRuleContext {
		public ITerminalNode AT() { return GetToken(VBAConditionalCompilationParser.AT, 0); }
		public ITerminalNode DOLLAR() { return GetToken(VBAConditionalCompilationParser.DOLLAR, 0); }
		public ITerminalNode EXCLAMATIONPOINT() { return GetToken(VBAConditionalCompilationParser.EXCLAMATIONPOINT, 0); }
		public ITerminalNode AMPERSAND() { return GetToken(VBAConditionalCompilationParser.AMPERSAND, 0); }
		public ITerminalNode PERCENT() { return GetToken(VBAConditionalCompilationParser.PERCENT, 0); }
		public ITerminalNode POW() { return GetToken(VBAConditionalCompilationParser.POW, 0); }
		public ITerminalNode HASH() { return GetToken(VBAConditionalCompilationParser.HASH, 0); }
		public TypeHintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeHint; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterTypeHint(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitTypeHint(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeHint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeHintContext typeHint() {
		TypeHintContext _localctx = new TypeHintContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_typeHint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 407;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EXCLAMATIONPOINT) | (1L << HASH) | (1L << AT) | (1L << PERCENT) | (1L << DOLLAR) | (1L << AMPERSAND))) != 0) || _la==POW) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public ITerminalNode INTEGERLITERAL() { return GetToken(VBAConditionalCompilationParser.INTEGERLITERAL, 0); }
		public ITerminalNode NULL() { return GetToken(VBAConditionalCompilationParser.NULL, 0); }
		public ITerminalNode STRINGLITERAL() { return GetToken(VBAConditionalCompilationParser.STRINGLITERAL, 0); }
		public ITerminalNode FALSE() { return GetToken(VBAConditionalCompilationParser.FALSE, 0); }
		public ITerminalNode TRUE() { return GetToken(VBAConditionalCompilationParser.TRUE, 0); }
		public ITerminalNode NOTHING() { return GetToken(VBAConditionalCompilationParser.NOTHING, 0); }
		public ITerminalNode DATELITERAL() { return GetToken(VBAConditionalCompilationParser.DATELITERAL, 0); }
		public ITerminalNode FLOATLITERAL() { return GetToken(VBAConditionalCompilationParser.FLOATLITERAL, 0); }
		public ITerminalNode HEXLITERAL() { return GetToken(VBAConditionalCompilationParser.HEXLITERAL, 0); }
		public ITerminalNode EMPTY() { return GetToken(VBAConditionalCompilationParser.EMPTY, 0); }
		public ITerminalNode OCTLITERAL() { return GetToken(VBAConditionalCompilationParser.OCTLITERAL, 0); }
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		public override void EnterRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IVBAConditionalCompilationParserListener typedListener = listener as IVBAConditionalCompilationParserListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IVBAConditionalCompilationParserVisitor<TResult> typedVisitor = visitor as IVBAConditionalCompilationParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_literal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 409;
			_la = _input.La(1);
			if ( !(((((_la - 57)) & ~0x3f) == 0 && ((1L << (_la - 57)) & ((1L << (EMPTY - 57)) | (1L << (FALSE - 57)) | (1L << (NOTHING - 57)) | (1L << (NULL - 57)))) != 0) || ((((_la - 169)) & ~0x3f) == 0 && ((1L << (_la - 169)) & ((1L << (TRUE - 169)) | (1L << (STRINGLITERAL - 169)) | (1L << (OCTLITERAL - 169)) | (1L << (HEXLITERAL - 169)) | (1L << (FLOATLITERAL - 169)) | (1L << (INTEGERLITERAL - 169)) | (1L << (DATELITERAL - 169)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 6: return ccExpression_sempred((CcExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool ccExpression_sempred(CcExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 17);

		case 1: return Precpred(_ctx, 15);

		case 2: return Precpred(_ctx, 14);

		case 3: return Precpred(_ctx, 13);

		case 4: return Precpred(_ctx, 12);

		case 5: return Precpred(_ctx, 11);

		case 6: return Precpred(_ctx, 10);

		case 7: return Precpred(_ctx, 8);

		case 8: return Precpred(_ctx, 7);

		case 9: return Precpred(_ctx, 6);

		case 10: return Precpred(_ctx, 5);

		case 11: return Precpred(_ctx, 4);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xDF\x19E\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\a\x3\x31\n\x3\f\x3\xE\x3\x34\v\x3"+
		"\x3\x4\a\x4\x37\n\x4\f\x4\xE\x4:\v\x4\x3\x4\x3\x4\x6\x4>\n\x4\r\x4\xE"+
		"\x4?\x3\x4\x3\x4\x6\x4\x44\n\x4\r\x4\xE\x4\x45\x3\x4\x3\x4\x6\x4J\n\x4"+
		"\r\x4\xE\x4K\x3\x4\x3\x4\x3\x4\x3\x5\x6\x5R\n\x5\r\x5\xE\x5S\x3\x6\x3"+
		"\x6\x6\x6X\n\x6\r\x6\xE\x6Y\x3\x6\x5\x6]\n\x6\x3\a\x3\a\x3\b\x3\b\x3\b"+
		"\a\b\x64\n\b\f\b\xE\bg\v\b\x3\b\x3\b\x3\b\a\bl\n\b\f\b\xE\bo\v\b\x3\b"+
		"\x3\b\x3\b\a\bt\n\b\f\b\xE\bw\v\b\x3\b\x3\b\a\b{\n\b\f\b\xE\b~\v\b\x3"+
		"\b\x3\b\x3\b\x3\b\x3\b\x5\b\x85\n\b\x3\b\x3\b\a\b\x89\n\b\f\b\xE\b\x8C"+
		"\v\b\x3\b\x3\b\a\b\x90\n\b\f\b\xE\b\x93\v\b\x3\b\x3\b\x3\b\a\b\x98\n\b"+
		"\f\b\xE\b\x9B\v\b\x3\b\x3\b\a\b\x9F\n\b\f\b\xE\b\xA2\v\b\x3\b\x3\b\x3"+
		"\b\a\b\xA7\n\b\f\b\xE\b\xAA\v\b\x3\b\x3\b\a\b\xAE\n\b\f\b\xE\b\xB1\v\b"+
		"\x3\b\x3\b\x3\b\a\b\xB6\n\b\f\b\xE\b\xB9\v\b\x3\b\x3\b\a\b\xBD\n\b\f\b"+
		"\xE\b\xC0\v\b\x3\b\x3\b\x3\b\a\b\xC5\n\b\f\b\xE\b\xC8\v\b\x3\b\x3\b\a"+
		"\b\xCC\n\b\f\b\xE\b\xCF\v\b\x3\b\x3\b\x3\b\a\b\xD4\n\b\f\b\xE\b\xD7\v"+
		"\b\x3\b\x3\b\a\b\xDB\n\b\f\b\xE\b\xDE\v\b\x3\b\x3\b\x3\b\a\b\xE3\n\b\f"+
		"\b\xE\b\xE6\v\b\x3\b\x3\b\a\b\xEA\n\b\f\b\xE\b\xED\v\b\x3\b\x3\b\x3\b"+
		"\a\b\xF2\n\b\f\b\xE\b\xF5\v\b\x3\b\x3\b\a\b\xF9\n\b\f\b\xE\b\xFC\v\b\x3"+
		"\b\x3\b\x3\b\a\b\x101\n\b\f\b\xE\b\x104\v\b\x3\b\x3\b\a\b\x108\n\b\f\b"+
		"\xE\b\x10B\v\b\x3\b\x3\b\x3\b\a\b\x110\n\b\f\b\xE\b\x113\v\b\x3\b\x3\b"+
		"\a\b\x117\n\b\f\b\xE\b\x11A\v\b\x3\b\x3\b\x3\b\a\b\x11F\n\b\f\b\xE\b\x122"+
		"\v\b\x3\b\x3\b\a\b\x126\n\b\f\b\xE\b\x129\v\b\x3\b\x3\b\x3\b\a\b\x12E"+
		"\n\b\f\b\xE\b\x131\v\b\x3\b\x3\b\a\b\x135\n\b\f\b\xE\b\x138\v\b\x3\b\a"+
		"\b\x13B\n\b\f\b\xE\b\x13E\v\b\x3\t\x3\t\x3\t\a\t\x143\n\t\f\t\xE\t\x146"+
		"\v\t\x3\t\x5\t\x149\n\t\x3\t\x3\t\x3\n\x3\n\x6\n\x14F\n\n\r\n\xE\n\x150"+
		"\x3\n\x3\n\x6\n\x155\n\n\r\n\xE\n\x156\x3\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3"+
		"\f\x3\f\x6\f\x161\n\f\r\f\xE\f\x162\x3\f\x3\f\x6\f\x167\n\f\r\f\xE\f\x168"+
		"\x3\f\x3\f\x3\f\x3\r\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x3\xF\x3\xF\x3\xF\x3"+
		"\x10\x3\x10\a\x10\x179\n\x10\f\x10\xE\x10\x17C\v\x10\x5\x10\x17E\n\x10"+
		"\x3\x10\x5\x10\x181\n\x10\x3\x11\x3\x11\x3\x11\a\x11\x186\n\x11\f\x11"+
		"\xE\x11\x189\v\x11\x3\x11\x3\x11\a\x11\x18D\n\x11\f\x11\xE\x11\x190\v"+
		"\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x13\x3\x13\x5\x13\x198\n\x13\x3\x14"+
		"\x3\x14\x3\x15\x3\x15\x3\x15\x2\x2\x3\xE\x16\x2\x2\x4\x2\x6\x2\b\x2\n"+
		"\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2"+
		" \x2\"\x2$\x2&\x2(\x2\x2\t\x3\x2\xC9\xCD\x4\x2\xBB\xBB\xC4\xC4\x4\x2\xC3"+
		"\xC3\xC6\xC6\a\x2]]\x66\x66\xBD\xC0\xC2\xC2\xC5\xC5\x3\x2\xD6\xD6\x5\x2"+
		"\x6\x6\b\f\xC7\xC7\a\x2;;OOtu\xAB\xAB\xD0\xD5\x1CD\x2*\x3\x2\x2\x2\x4"+
		"\x32\x3\x2\x2\x2\x6\x38\x3\x2\x2\x2\bQ\x3\x2\x2\x2\nW\x3\x2\x2\x2\f^\x3"+
		"\x2\x2\x2\xE\x84\x3\x2\x2\x2\x10\x13F\x3\x2\x2\x2\x12\x14C\x3\x2\x2\x2"+
		"\x14\x15B\x3\x2\x2\x2\x16\x15E\x3\x2\x2\x2\x18\x16D\x3\x2\x2\x2\x1A\x170"+
		"\x3\x2\x2\x2\x1C\x173\x3\x2\x2\x2\x1E\x17D\x3\x2\x2\x2 \x182\x3\x2\x2"+
		"\x2\"\x193\x3\x2\x2\x2$\x195\x3\x2\x2\x2&\x199\x3\x2\x2\x2(\x19B\x3\x2"+
		"\x2\x2*+\x5\x4\x3\x2+,\a\x2\x2\x3,\x3\x3\x2\x2\x2-\x31\x5\x6\x4\x2.\x31"+
		"\x5\x10\t\x2/\x31\x5\b\x5\x2\x30-\x3\x2\x2\x2\x30.\x3\x2\x2\x2\x30/\x3"+
		"\x2\x2\x2\x31\x34\x3\x2\x2\x2\x32\x30\x3\x2\x2\x2\x32\x33\x3\x2\x2\x2"+
		"\x33\x5\x3\x2\x2\x2\x34\x32\x3\x2\x2\x2\x35\x37\a\xDB\x2\x2\x36\x35\x3"+
		"\x2\x2\x2\x37:\x3\x2\x2\x2\x38\x36\x3\x2\x2\x2\x38\x39\x3\x2\x2\x2\x39"+
		";\x3\x2\x2\x2:\x38\x3\x2\x2\x2;=\a\xC9\x2\x2<>\a\xDB\x2\x2=<\x3\x2\x2"+
		"\x2>?\x3\x2\x2\x2?=\x3\x2\x2\x2?@\x3\x2\x2\x2@\x41\x3\x2\x2\x2\x41\x43"+
		"\x5\f\a\x2\x42\x44\a\xDB\x2\x2\x43\x42\x3\x2\x2\x2\x44\x45\x3\x2\x2\x2"+
		"\x45\x43\x3\x2\x2\x2\x45\x46\x3\x2\x2\x2\x46G\x3\x2\x2\x2GI\a\xBD\x2\x2"+
		"HJ\a\xDB\x2\x2IH\x3\x2\x2\x2JK\x3\x2\x2\x2KI\x3\x2\x2\x2KL\x3\x2\x2\x2"+
		"LM\x3\x2\x2\x2MN\x5\xE\b\x2NO\x5\x1E\x10\x2O\a\x3\x2\x2\x2PR\x5\n\x6\x2"+
		"QP\x3\x2\x2\x2RS\x3\x2\x2\x2SQ\x3\x2\x2\x2ST\x3\x2\x2\x2T\t\x3\x2\x2\x2"+
		"UX\a\xDD\x2\x2VX\n\x2\x2\x2WU\x3\x2\x2\x2WV\x3\x2\x2\x2XY\x3\x2\x2\x2"+
		"YW\x3\x2\x2\x2YZ\x3\x2\x2\x2Z\\\x3\x2\x2\x2[]\a\xD6\x2\x2\\[\x3\x2\x2"+
		"\x2\\]\x3\x2\x2\x2]\v\x3\x2\x2\x2^_\x5$\x13\x2_\r\x3\x2\x2\x2`\x61\b\b"+
		"\x1\x2\x61\x65\a\xC3\x2\x2\x62\x64\a\xDB\x2\x2\x63\x62\x3\x2\x2\x2\x64"+
		"g\x3\x2\x2\x2\x65\x63\x3\x2\x2\x2\x65\x66\x3\x2\x2\x2\x66h\x3\x2\x2\x2"+
		"g\x65\x3\x2\x2\x2h\x85\x5\xE\b\x12im\as\x2\x2jl\a\xDB\x2\x2kj\x3\x2\x2"+
		"\x2lo\x3\x2\x2\x2mk\x3\x2\x2\x2mn\x3\x2\x2\x2np\x3\x2\x2\x2om\x3\x2\x2"+
		"\x2p\x85\x5\xE\b\vqu\a\xC1\x2\x2rt\a\xDB\x2\x2sr\x3\x2\x2\x2tw\x3\x2\x2"+
		"\x2us\x3\x2\x2\x2uv\x3\x2\x2\x2vx\x3\x2\x2\x2wu\x3\x2\x2\x2x|\x5\xE\b"+
		"\x2y{\a\xDB\x2\x2zy\x3\x2\x2\x2{~\x3\x2\x2\x2|z\x3\x2\x2\x2|}\x3\x2\x2"+
		"\x2}\x7F\x3\x2\x2\x2~|\x3\x2\x2\x2\x7F\x80\a\xC8\x2\x2\x80\x85\x3\x2\x2"+
		"\x2\x81\x85\x5 \x11\x2\x82\x85\x5(\x15\x2\x83\x85\x5$\x13\x2\x84`\x3\x2"+
		"\x2\x2\x84i\x3\x2\x2\x2\x84q\x3\x2\x2\x2\x84\x81\x3\x2\x2\x2\x84\x82\x3"+
		"\x2\x2\x2\x84\x83\x3\x2\x2\x2\x85\x13C\x3\x2\x2\x2\x86\x8A\f\x13\x2\x2"+
		"\x87\x89\a\xDB\x2\x2\x88\x87\x3\x2\x2\x2\x89\x8C\x3\x2\x2\x2\x8A\x88\x3"+
		"\x2\x2\x2\x8A\x8B\x3\x2\x2\x2\x8B\x8D\x3\x2\x2\x2\x8C\x8A\x3\x2\x2\x2"+
		"\x8D\x91\a\xC7\x2\x2\x8E\x90\a\xDB\x2\x2\x8F\x8E\x3\x2\x2\x2\x90\x93\x3"+
		"\x2\x2\x2\x91\x8F\x3\x2\x2\x2\x91\x92\x3\x2\x2\x2\x92\x94\x3\x2\x2\x2"+
		"\x93\x91\x3\x2\x2\x2\x94\x13B\x5\xE\b\x14\x95\x99\f\x11\x2\x2\x96\x98"+
		"\a\xDB\x2\x2\x97\x96\x3\x2\x2\x2\x98\x9B\x3\x2\x2\x2\x99\x97\x3\x2\x2"+
		"\x2\x99\x9A\x3\x2\x2\x2\x9A\x9C\x3\x2\x2\x2\x9B\x99\x3\x2\x2\x2\x9C\xA0"+
		"\t\x3\x2\x2\x9D\x9F\a\xDB\x2\x2\x9E\x9D\x3\x2\x2\x2\x9F\xA2\x3\x2\x2\x2"+
		"\xA0\x9E\x3\x2\x2\x2\xA0\xA1\x3\x2\x2\x2\xA1\xA3\x3\x2\x2\x2\xA2\xA0\x3"+
		"\x2\x2\x2\xA3\x13B\x5\xE\b\x12\xA4\xA8\f\x10\x2\x2\xA5\xA7\a\xDB\x2\x2"+
		"\xA6\xA5\x3\x2\x2\x2\xA7\xAA\x3\x2\x2\x2\xA8\xA6\x3\x2\x2\x2\xA8\xA9\x3"+
		"\x2\x2\x2\xA9\xAB\x3\x2\x2\x2\xAA\xA8\x3\x2\x2\x2\xAB\xAF\a\xBC\x2\x2"+
		"\xAC\xAE\a\xDB\x2\x2\xAD\xAC\x3\x2\x2\x2\xAE\xB1\x3\x2\x2\x2\xAF\xAD\x3"+
		"\x2\x2\x2\xAF\xB0\x3\x2\x2\x2\xB0\xB2\x3\x2\x2\x2\xB1\xAF\x3\x2\x2\x2"+
		"\xB2\x13B\x5\xE\b\x11\xB3\xB7\f\xF\x2\x2\xB4\xB6\a\xDB\x2\x2\xB5\xB4\x3"+
		"\x2\x2\x2\xB6\xB9\x3\x2\x2\x2\xB7\xB5\x3\x2\x2\x2\xB7\xB8\x3\x2\x2\x2"+
		"\xB8\xBA\x3\x2\x2\x2\xB9\xB7\x3\x2\x2\x2\xBA\xBE\ao\x2\x2\xBB\xBD\a\xDB"+
		"\x2\x2\xBC\xBB\x3\x2\x2\x2\xBD\xC0\x3\x2\x2\x2\xBE\xBC\x3\x2\x2\x2\xBE"+
		"\xBF\x3\x2\x2\x2\xBF\xC1\x3\x2\x2\x2\xC0\xBE\x3\x2\x2\x2\xC1\x13B\x5\xE"+
		"\b\x10\xC2\xC6\f\xE\x2\x2\xC3\xC5\a\xDB\x2\x2\xC4\xC3\x3\x2\x2\x2\xC5"+
		"\xC8\x3\x2\x2\x2\xC6\xC4\x3\x2\x2\x2\xC6\xC7\x3\x2\x2\x2\xC7\xC9\x3\x2"+
		"\x2\x2\xC8\xC6\x3\x2\x2\x2\xC9\xCD\t\x4\x2\x2\xCA\xCC\a\xDB\x2\x2\xCB"+
		"\xCA\x3\x2\x2\x2\xCC\xCF\x3\x2\x2\x2\xCD\xCB\x3\x2\x2\x2\xCD\xCE\x3\x2"+
		"\x2\x2\xCE\xD0\x3\x2\x2\x2\xCF\xCD\x3\x2\x2\x2\xD0\x13B\x5\xE\b\xF\xD1"+
		"\xD5\f\r\x2\x2\xD2\xD4\a\xDB\x2\x2\xD3\xD2\x3\x2\x2\x2\xD4\xD7\x3\x2\x2"+
		"\x2\xD5\xD3\x3\x2\x2\x2\xD5\xD6\x3\x2\x2\x2\xD6\xD8\x3\x2\x2\x2\xD7\xD5"+
		"\x3\x2\x2\x2\xD8\xDC\a\f\x2\x2\xD9\xDB\a\xDB\x2\x2\xDA\xD9\x3\x2\x2\x2"+
		"\xDB\xDE\x3\x2\x2\x2\xDC\xDA\x3\x2\x2\x2\xDC\xDD\x3\x2\x2\x2\xDD\xDF\x3"+
		"\x2\x2\x2\xDE\xDC\x3\x2\x2\x2\xDF\x13B\x5\xE\b\xE\xE0\xE4\f\f\x2\x2\xE1"+
		"\xE3\a\xDB\x2\x2\xE2\xE1\x3\x2\x2\x2\xE3\xE6\x3\x2\x2\x2\xE4\xE2\x3\x2"+
		"\x2\x2\xE4\xE5\x3\x2\x2\x2\xE5\xE7\x3\x2\x2\x2\xE6\xE4\x3\x2\x2\x2\xE7"+
		"\xEB\t\x5\x2\x2\xE8\xEA\a\xDB\x2\x2\xE9\xE8\x3\x2\x2\x2\xEA\xED\x3\x2"+
		"\x2\x2\xEB\xE9\x3\x2\x2\x2\xEB\xEC\x3\x2\x2\x2\xEC\xEE\x3\x2\x2\x2\xED"+
		"\xEB\x3\x2\x2\x2\xEE\x13B\x5\xE\b\r\xEF\xF3\f\n\x2\x2\xF0\xF2\a\xDB\x2"+
		"\x2\xF1\xF0\x3\x2\x2\x2\xF2\xF5\x3\x2\x2\x2\xF3\xF1\x3\x2\x2\x2\xF3\xF4"+
		"\x3\x2\x2\x2\xF4\xF6\x3\x2\x2\x2\xF5\xF3\x3\x2\x2\x2\xF6\xFA\a\x10\x2"+
		"\x2\xF7\xF9\a\xDB\x2\x2\xF8\xF7\x3\x2\x2\x2\xF9\xFC\x3\x2\x2\x2\xFA\xF8"+
		"\x3\x2\x2\x2\xFA\xFB\x3\x2\x2\x2\xFB\xFD\x3\x2\x2\x2\xFC\xFA\x3\x2\x2"+
		"\x2\xFD\x13B\x5\xE\b\v\xFE\x102\f\t\x2\x2\xFF\x101\a\xDB\x2\x2\x100\xFF"+
		"\x3\x2\x2\x2\x101\x104\x3\x2\x2\x2\x102\x100\x3\x2\x2\x2\x102\x103\x3"+
		"\x2\x2\x2\x103\x105\x3\x2\x2\x2\x104\x102\x3\x2\x2\x2\x105\x109\a\x7F"+
		"\x2\x2\x106\x108\a\xDB\x2\x2\x107\x106\x3\x2\x2\x2\x108\x10B\x3\x2\x2"+
		"\x2\x109\x107\x3\x2\x2\x2\x109\x10A\x3\x2\x2\x2\x10A\x10C\x3\x2\x2\x2"+
		"\x10B\x109\x3\x2\x2\x2\x10C\x13B\x5\xE\b\n\x10D\x111\f\b\x2\x2\x10E\x110"+
		"\a\xDB\x2\x2\x10F\x10E\x3\x2\x2\x2\x110\x113\x3\x2\x2\x2\x111\x10F\x3"+
		"\x2\x2\x2\x111\x112\x3\x2\x2\x2\x112\x114\x3\x2\x2\x2\x113\x111\x3\x2"+
		"\x2\x2\x114\x118\a\xB9\x2\x2\x115\x117\a\xDB\x2\x2\x116\x115\x3\x2\x2"+
		"\x2\x117\x11A\x3\x2\x2\x2\x118\x116\x3\x2\x2\x2\x118\x119\x3\x2\x2\x2"+
		"\x119\x11B\x3\x2\x2\x2\x11A\x118\x3\x2\x2\x2\x11B\x13B\x5\xE\b\t\x11C"+
		"\x120\f\a\x2\x2\x11D\x11F\a\xDB\x2\x2\x11E\x11D\x3\x2\x2\x2\x11F\x122"+
		"\x3\x2\x2\x2\x120\x11E\x3\x2\x2\x2\x120\x121\x3\x2\x2\x2\x121\x123\x3"+
		"\x2\x2\x2\x122\x120\x3\x2\x2\x2\x123\x127\a\x46\x2\x2\x124\x126\a\xDB"+
		"\x2\x2\x125\x124\x3\x2\x2\x2\x126\x129\x3\x2\x2\x2\x127\x125\x3\x2\x2"+
		"\x2\x127\x128\x3\x2\x2\x2\x128\x12A\x3\x2\x2\x2\x129\x127\x3\x2\x2\x2"+
		"\x12A\x13B\x5\xE\b\b\x12B\x12F\f\x6\x2\x2\x12C\x12E\a\xDB\x2\x2\x12D\x12C"+
		"\x3\x2\x2\x2\x12E\x131\x3\x2\x2\x2\x12F\x12D\x3\x2\x2\x2\x12F\x130\x3"+
		"\x2\x2\x2\x130\x132\x3\x2\x2\x2\x131\x12F\x3\x2\x2\x2\x132\x136\aY\x2"+
		"\x2\x133\x135\a\xDB\x2\x2\x134\x133\x3\x2\x2\x2\x135\x138\x3\x2\x2\x2"+
		"\x136\x134\x3\x2\x2\x2\x136\x137\x3\x2\x2\x2\x137\x139\x3\x2\x2\x2\x138"+
		"\x136\x3\x2\x2\x2\x139\x13B\x5\xE\b\a\x13A\x86\x3\x2\x2\x2\x13A\x95\x3"+
		"\x2\x2\x2\x13A\xA4\x3\x2\x2\x2\x13A\xB3\x3\x2\x2\x2\x13A\xC2\x3\x2\x2"+
		"\x2\x13A\xD1\x3\x2\x2\x2\x13A\xE0\x3\x2\x2\x2\x13A\xEF\x3\x2\x2\x2\x13A"+
		"\xFE\x3\x2\x2\x2\x13A\x10D\x3\x2\x2\x2\x13A\x11C\x3\x2\x2\x2\x13A\x12B"+
		"\x3\x2\x2\x2\x13B\x13E\x3\x2\x2\x2\x13C\x13A\x3\x2\x2\x2\x13C\x13D\x3"+
		"\x2\x2\x2\x13D\xF\x3\x2\x2\x2\x13E\x13C\x3\x2\x2\x2\x13F\x140\x5\x12\n"+
		"\x2\x140\x144\x5\x4\x3\x2\x141\x143\x5\x14\v\x2\x142\x141\x3\x2\x2\x2"+
		"\x143\x146\x3\x2\x2\x2\x144\x142\x3\x2\x2\x2\x144\x145\x3\x2\x2\x2\x145"+
		"\x148\x3\x2\x2\x2\x146\x144\x3\x2\x2\x2\x147\x149\x5\x18\r\x2\x148\x147"+
		"\x3\x2\x2\x2\x148\x149\x3\x2\x2\x2\x149\x14A\x3\x2\x2\x2\x14A\x14B\x5"+
		"\x1C\xF\x2\x14B\x11\x3\x2\x2\x2\x14C\x14E\a\xCA\x2\x2\x14D\x14F\a\xDB"+
		"\x2\x2\x14E\x14D\x3\x2\x2\x2\x14F\x150\x3\x2\x2\x2\x150\x14E\x3\x2\x2"+
		"\x2\x150\x151\x3\x2\x2\x2\x151\x152\x3\x2\x2\x2\x152\x154\x5\xE\b\x2\x153"+
		"\x155\a\xDB\x2\x2\x154\x153\x3\x2\x2\x2\x155\x156\x3\x2\x2\x2\x156\x154"+
		"\x3\x2\x2\x2\x156\x157\x3\x2\x2\x2\x157\x158\x3\x2\x2\x2\x158\x159\a\xA8"+
		"\x2\x2\x159\x15A\x5\x1E\x10\x2\x15A\x13\x3\x2\x2\x2\x15B\x15C\x5\x16\f"+
		"\x2\x15C\x15D\x5\x4\x3\x2\x15D\x15\x3\x2\x2\x2\x15E\x160\a\xCB\x2\x2\x15F"+
		"\x161\a\xDB\x2\x2\x160\x15F\x3\x2\x2\x2\x161\x162\x3\x2\x2\x2\x162\x160"+
		"\x3\x2\x2\x2\x162\x163\x3\x2\x2\x2\x163\x164\x3\x2\x2\x2\x164\x166\x5"+
		"\xE\b\x2\x165\x167\a\xDB\x2\x2\x166\x165\x3\x2\x2\x2\x167\x168\x3\x2\x2"+
		"\x2\x168\x166\x3\x2\x2\x2\x168\x169\x3\x2\x2\x2\x169\x16A\x3\x2\x2\x2"+
		"\x16A\x16B\a\xA8\x2\x2\x16B\x16C\x5\x1E\x10\x2\x16C\x17\x3\x2\x2\x2\x16D"+
		"\x16E\x5\x1A\xE\x2\x16E\x16F\x5\x4\x3\x2\x16F\x19\x3\x2\x2\x2\x170\x171"+
		"\a\xCC\x2\x2\x171\x172\x5\x1E\x10\x2\x172\x1B\x3\x2\x2\x2\x173\x174\a"+
		"\xCD\x2\x2\x174\x175\x5\x1E\x10\x2\x175\x1D\x3\x2\x2\x2\x176\x17A\a\xD9"+
		"\x2\x2\x177\x179\n\x6\x2\x2\x178\x177\x3\x2\x2\x2\x179\x17C\x3\x2\x2\x2"+
		"\x17A\x178\x3\x2\x2\x2\x17A\x17B\x3\x2\x2\x2\x17B\x17E\x3\x2\x2\x2\x17C"+
		"\x17A\x3\x2\x2\x2\x17D\x176\x3\x2\x2\x2\x17D\x17E\x3\x2\x2\x2\x17E\x180"+
		"\x3\x2\x2\x2\x17F\x181\a\xD6\x2\x2\x180\x17F\x3\x2\x2\x2\x180\x181\x3"+
		"\x2\x2\x2\x181\x1F\x3\x2\x2\x2\x182\x183\x5\"\x12\x2\x183\x187\a\xC1\x2"+
		"\x2\x184\x186\a\xDB\x2\x2\x185\x184\x3\x2\x2\x2\x186\x189\x3\x2\x2\x2"+
		"\x187\x185\x3\x2\x2\x2\x187\x188\x3\x2\x2\x2\x188\x18A\x3\x2\x2\x2\x189"+
		"\x187\x3\x2\x2\x2\x18A\x18E\x5\xE\b\x2\x18B\x18D\a\xDB\x2\x2\x18C\x18B"+
		"\x3\x2\x2\x2\x18D\x190\x3\x2\x2\x2\x18E\x18C\x3\x2\x2\x2\x18E\x18F\x3"+
		"\x2\x2\x2\x18F\x191\x3\x2\x2\x2\x190\x18E\x3\x2\x2\x2\x191\x192\a\xC8"+
		"\x2\x2\x192!\x3\x2\x2\x2\x193\x194\a\xDC\x2\x2\x194#\x3\x2\x2\x2\x195"+
		"\x197\a\xDC\x2\x2\x196\x198\x5&\x14\x2\x197\x196\x3\x2\x2\x2\x197\x198"+
		"\x3\x2\x2\x2\x198%\x3\x2\x2\x2\x199\x19A\t\a\x2\x2\x19A\'\x3\x2\x2\x2"+
		"\x19B\x19C\t\b\x2\x2\x19C)\x3\x2\x2\x2\x37\x30\x32\x38?\x45KSWY\\\x65"+
		"mu|\x84\x8A\x91\x99\xA0\xA8\xAF\xB7\xBE\xC6\xCD\xD5\xDC\xE4\xEB\xF3\xFA"+
		"\x102\x109\x111\x118\x120\x127\x12F\x136\x13A\x13C\x144\x148\x150\x156"+
		"\x162\x168\x17A\x17D\x180\x187\x18E\x197";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Rubberduck.Parsing.Preprocessing
